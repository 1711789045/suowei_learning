/*********************************************************************************************************************
* 文件名称: pid.c
* 功能说明: PID控制模块 - 增量式PID算法
* 作者: Claude Code
* 日期: 2025-10-27
********************************************************************************************************************/

#include "pid.h"

// 全局PID参数(左右电机共享,可通过菜单调整)
float motor_kp = 0.0f;          // 比例系数(初值=0)
float motor_ki = 0.0f;          // 积分系数(初值=0)
float motor_kd = 0.0f;          // 微分系数(初值=0)

/*********************************************************************************************************************
* 函数名称: pid_init
* 功能说明: 初始化PID参数
* 参数说明: 无
* 返回值:   无
* 备注:     参数初始值为0,需通过菜单调整
********************************************************************************************************************/
void pid_init(void)
{
    motor_kp = 0.0f;
    motor_ki = 0.0f;
    motor_kd = 0.0f;

    printf("[PID] Init OK - Kp=%.2f Ki=%.2f Kd=%.2f\r\n", motor_kp, motor_ki, motor_kd);
}

/*********************************************************************************************************************
* 函数名称: pid_reset
* 功能说明: 重置PID状态(清空历史误差和输出)
* 参数说明: pid - PID状态结构体指针
* 返回值:   无
* 备注:     切换控制目标或启动时调用,避免历史误差影响
********************************************************************************************************************/
void pid_reset(pid_t *pid)
{
    pid->error_last = 0.0f;
    pid->error_last2 = 0.0f;
    pid->output = 0.0f;
}

/*********************************************************************************************************************
* 函数名称: pid_calc
* 功能说明: 计算PID输出(增量式)
* 参数说明: pid    - PID状态结构体指针
*           target - 目标值
*           actual - 实际值
* 返回值:   float - PID控制输出
* 备注:     增量式PID公式: Δu(k) = Kp*[e(k)-e(k-1)] + Ki*e(k) + Kd*[e(k)-2*e(k-1)+e(k-2)]
*           输出累加: u(k) = u(k-1) + Δu(k)
********************************************************************************************************************/
float pid_calc(pid_t *pid, float target, float actual)
{
    // 计算当前误差 e(k)
    float error = target - actual;

    // 计算增量式PID各项
    float delta_p = motor_kp * (error - pid->error_last);                          // 比例项增量
    float delta_i = motor_ki * error;                                               // 积分项（误差本身）
    float delta_d = motor_kd * (error - 2.0f * pid->error_last + pid->error_last2); // 微分项增量

    // 计算总增量
    float delta_output = delta_p + delta_i + delta_d;

    // 累加到输出
    pid->output += delta_output;

    // 限幅（防止积分饱和）
    if (pid->output > 10000.0f)
        pid->output = 10000.0f;
    else if (pid->output < -10000.0f)
        pid->output = -10000.0f;

    // 更新历史误差
    pid->error_last2 = pid->error_last;
    pid->error_last = error;

    return pid->output;
}
